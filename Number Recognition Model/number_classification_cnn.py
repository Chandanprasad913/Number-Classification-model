# -*- coding: utf-8 -*-
"""Number_Classification_CNN.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Hdak4LrdtxfykEdTGzsvMPqlXpkqrJp4
"""

# CNN --
# required Librearies --
import tensorflow as tf
from tensorflow.keras import layers, models
import matplotlib.pyplot as plt

# fashion_mnist = tf.keras.datasets.fashion_mnist
fashion_mnist = tf.keras.datasets.mnist
(x_train, y_train), (x_test, y_test) = fashion_mnist.load_data()

fashion_mnist

x_train = x_train / 255.0
x_test = x_test / 255.0

x_train = x_train.reshape(-1, 28, 28, 1)
x_test = x_test.reshape(-1, 28, 28, 1)

model = models.Sequential([
    layers.Conv2D(32, (3, 3), activation='relu', input_shape=(28, 28, 1)),
    layers.MaxPooling2D((2,2)),
    layers.Conv2D(64, (3, 3), activation='relu'),
    layers.MaxPooling2D((2,2)),
    layers.Conv2D(64, (3, 3), activation='relu'),
    layers.MaxPooling2D((2,2)),
    layers.Flatten(),
    layers.Dense(64,activation="relu"),
    layers.Dense(10,activation="softmax")
])

model.compile(optimizer='adam',
              loss='sparse_categorical_crossentropy',
              metrics=['accuracy'])
history = model.fit(x_train,y_train,epochs=10,validation_split=0.1,batch_size = 6)

test_loss, test_acc = model.evaluate(x_test, y_test,verbose = 2)
print(f"Test Accuracy: {test_acc:.4f}")

import numpy as np
predictions = model.predict(x_test[:10])
predicted_labels = np.argmax(predictions, axis=1)
true_labels = y_test[:10]

print("Predicted labels:", predicted_labels)
print("True labels:", true_labels)

# class_name = ["T-shirt/top","Trouser","Pullover","Dress","Coat","Sandal","Shirt","Sneaker","Bag","Ankle boot"]
class_name = ["0","1","2","3","4","5","6","7","8","9"]
plt.figure(figsize=(20,5))
for i in range(10):
    plt.subplot(1,10,i+1)
    plt.imshow(x_test[i].reshape(28,28),cmap = "gray")
    plt.title(f"Pred : -{class_name[predicted_labels[i]]}\nTrue:{class_name[true_labels[i]]}")
    plt.axis("off")
plt.show()

from IPython.display import display
from PIL import Image
import ipywidgets as widgets
from io import BytesIO
import numpy as np
import matplotlib.pyplot as plt

upload = widgets.FileUpload(
    description ="Pick Image",
    accept = "image/*",
    multiple = False
)

def upload_image(change):
    # The actual file content is in upload.value, not change['new']
    # Since multiple=False, we expect only one file
    uploaded_file_name = list(upload.value.keys())[0]
    content = upload.value[uploaded_file_name]['content']

    # convert to PIL image
    image = Image.open(BytesIO(content))
    # convert to grayscale
    image = image.convert("L")
    # resize
    image = image.resize((28,28))

    image_array = np.array(image)/255.0

    # Invert colors as Fashion MNIST images are usually white on black
    image_array = 1 - image_array

    model_input = image_array.reshape(1,28,28,1)

    # model prediction
    predictions = model.predict(model_input)
    predicted_label = np.argmax(predictions)
    confidence = np.max(predictions)

    # Display  -
    plt.imshow(image_array,cmap= "gray")
    plt.title(f"Prediction: {class_name[predicted_label]}\nConfidence: {confidence:.2%}")
    plt.axis("off")
    plt.show()
upload.observe(upload_image, names='value') # Observe 'value' trait for file uploads

display(upload)

